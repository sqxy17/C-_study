//一、输出东西的时候，怎么舒服怎么来     ---想用c的格式就用c的格式，想用c++的格式就用c++的格式
#include<iostream>                //-----后续的函数都不将这个头文件在注释了，下面的函数都能进行使用
//using namespace std;
//typedef int* pstring;
//int main()
//{
//    int a=9;
//    int
//}



//二、缺省参数  （又叫默认参数）        --字面意思
//using namespace std;
////单个缺省参数
//void test(int a=5)//缺省参数就是函数在调用的时候可以不输入参数进行调用
//{
//    cout<<a<<endl;
//}
//
////全缺省
//void test1(int a=3,int b=2,int c=3)//这种也叫全缺省，也就是所有参数都给了缺省值
//{
//    cout<<a<<endl;
//    cout<<b<<endl;
//    cout<<c<<endl;
//
//}
//
//
////半缺省
//void test2(int a,int b=2,int c=3)//这样的半缺省参数必须是从a开始，并且是连续的才能缺省。也就是可以int a,int b,int c=2;   但是不能int a=1;int b,int c=2;
//
//{
//    cout<<a<<endl;
//    cout<<b<<endl;
//    cout<<c<<endl;
//}
//
//
//int main(void)
//{
//    test(10086);//在传实参的时候，诶调用函数会按照实参的值执行程序
//    test();//如果没有传参，提前定义的5就会当做实参进行执行
//
//    test1();//多个缺省值也是一样的
//    test1(1,2);//多个缺省值传参的时候是从左往右传的      但是穿参的时候不能跳着传参，也就是不能指定传参
//
//    test2(1);//a没有缺省参数所以最少要有一个参数
//}





//三、缺省参数函数的定义和声明
//如果一个缺省参数函数在test.c中定义，如;
//int test(int a=1,int b=2)
//{
//    return a+b;
//}

//那么函数的声明就不能在有参数缺省的情况       假设这个声明在test.h中
//int test(int a,int b);//声明的时候不能再进行缺省参数


//函数的声明和函数的定义在同一个文件中也是这样要求的








//四、函数重载
//1.函数重载概念：是函数的一种特殊情况，c++允许在 同一作用域 中， 声明 几个功能类似的同名函数，这些同名函数的形参列表，（参数个数，或者参数类型，再或者参数顺序）不同
//常用来处理实现功能类似，但数据类型不同的问题               参数个数，参数类型，参数顺序有一个不算就算重载
//但是返回值不同，不构成重载

//参数个数不同
//int add(int a,int b,int c)
//{
//    return a+b+c;
//}

//int add(int a,int b)
//{
//    return a+b;
//}


//参数类型不同
//int add(int a,int b)
//{
//    return a+b;
//}
//
//double add(double a,double b)
//{
//    return a+b;
//}


//参数顺序不同
//int add(char a,int b)//并且注意，这个顺序不同前提是里面的形参是不同类型的。否则不能构成重载
//{
//    return a+b;
//}
//
//int add(int b,char a)
//{
//    return a+b;
//}


//补充：严格把握三个要求。参数个数、类型、顺序
//但是也要避免缺省参数带来的歧义
//int add()
//{
//    return 3;
//}
//
//int add(int a=3)
//{
//    return a;
//}
//上面的两个函数肯定是构成重载的，但是像这样的调用就会出现问题  add();   这样就不知道编译器调用的add(),还是缺省参数add(int a=3);使用默认参数






//五、c++函数重载的原理（为什么c不支持，c++支持，c++支持重载的原理是什么）       ----见配套的同名word文档
//linux下gcc编译器是c的编译器   g++是c++的编译器，但是向下支持
//windows系统下面是根据文件的后缀来调用相应的编译器   .c调用的就是c编译器   .cpp调用的就是c++的编译器
//这个地方在学完linux时必须拐回来看一遍，还有函数栈帧的创建和销毁
//未看
